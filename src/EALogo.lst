; ===========================================================================
; EALogoEntry: Entry point for the EA logo animation sequence
; Initializes and controls the EA logo animation, where the ECA letters flip
; into place (green E, yellow C, blue A) and the "ELECTRONIC ARTS" wordmark
; slides in from both sides, starting green, changing to match each letter's
; color, and fading out.
; ===========================================================================
ROM:00000306 EALogoEntry:
ROM:00000306                 bsr.w   ReadControllerInput ; Call subroutine to read controller input
ROM:0000030A                 bsr.w   InitVDPForLogo     ; Initialize VDP for logo display
ROM:0000030E                 bsr.w   ReadControllerInput ; Call controller input again (clear buffer)
ROM:00000312                 move.w  #0,(Controller1Input).l ; Clear controller 1 input buffer
ROM:0000031A                 move.w  #0,(Controller2Input).l ; Clear controller 2 input buffer

; Wait for VDP vertical blank to ensure screen is ready for rendering
ROM:00000322 WaitVBlank:                             ; CODE XREF: EALogoEntry+12C↓j
ROM:00000322                 move.w  (VDP_CTRL).l,d0  ; Read VDP control port
ROM:00000328                 btst    #1,d0            ; Check vertical blank flag
ROM:0000032C                 bne.s   WaitVBlank       ; Loop until vertical blank occurs
ROM:0000032E                 move.w  #$8174,(VDP_CTRL).l ; Enable display (VDP register #1)

; Wait for VDP sprite processing completion
ROM:00000336 WaitSpriteProcessing:                  ; CODE XREF: EALogoEntry+140↓j
ROM:00000336                                         ; EALogoEntry+16A↓j
ROM:00000336                 move.w  (VDP_CTRL).l,d1  ; Read VDP control port
ROM:0000033C                 btst    #3,d1            ; Check sprite overflow flag
ROM:00000340                 bne.s   WaitSpriteProcessing ; Loop if sprite processing active
ROM:00000342 CheckSpriteProcessing:                 ; CODE XREF: EALogoEntry+14C↓j
ROM:00000342                 move.w  (VDP_CTRL).l,d1  ; Read VDP control port
ROM:00000348                 btst    #3,d1            ; Check sprite overflow flag
ROM:0000034C                 beq.s   CheckSpriteProcessing ; Loop until sprite processing starts
ROM:0000034E                 bsr.w   ReadControllerInput ; Read controller input
ROM:00000352                 andi.w  #$FF,d0          ; Mask controller 1 input
ROM:00000356                 bne.s   ExitLogoAnimation  ; Skip if input detected
ROM:00000358                 andi.w  #$FF,d1          ; Mask controller 2 input
ROM:0000035C                 bne.s   ExitLogoAnimation  ; Skip if input detected
ROM:0000035E                 bsr.w   AnimateEALogo      ; Call main logo animation subroutine
ROM:00000362                 cmpi.w  #0,(AnimationCompleteFlag).l ; Check if animation is complete
ROM:0000036A                 beq.s   WaitSpriteProcessing ; Loop if animation not complete
ROM:0000036C ExitLogoAnimation:                     ; CODE XREF: EALogoEntry+156↑j
ROM:0000036C                                         ; EALogoEntry+15C↑j
ROM:0000036C                 bra.w   NextProgramSection ; Jump to next program section
ROM:0000036C ; End of function EALogoEntry

; ===========================================================================
; ReadControllerInput: Reads controller input
; Reads input from controllers 1 and 2, storing results in memory. Allows
; skipping the logo animation if a button is pressed.
; ===========================================================================
ROM:00000370 ReadControllerInput:                    ; CODE XREF: EALogoEntry↑p
ROM:00000370                                         ; EALogoEntry+10E↑p ...
ROM:00000370                 move.b  #$40,(IO_CT1_CTRL+1).l ; Set controller 1 control port
ROM:00000378                 move.b  #0,(IO_CT1_DATA+1).l ; Clear controller 1 data
ROM:00000380                 move.w  #$A,d1           ; Set delay counter
ROM:00000384 DelayController1Read:                  ; CODE XREF: ReadControllerInput:DelayController1Read↓j
ROM:00000384                 dbf     d1,DelayController1Read ; Delay loop
ROM:00000388                 move.b  (IO_CT1_DATA+1).l,d0 ; Read controller 1 data
ROM:0000038E                 asl.b   #2,d0            ; Shift bits for button mask
ROM:00000390                 andi.b  #$C0,d0          ; Mask Start/A buttons
ROM:00000394                 move.b  #$40,(IO_CT1_DATA+1).l ; Set controller 1 data
ROM:0000039C                 move.w  #$A,d1           ; Set delay counter
ROM:000003A0 DelayController1SecondRead:            ; CODE XREF: ReadControllerInput:DelayController1SecondRead↓j
ROM:000003A0                 dbf     d1,DelayController1SecondRead ; Delay loop
ROM:000003A4                 move.b  (IO_CT1_DATA+1).l,d1 ; Read controller 1 data
ROM:000003AA                 andi.b  #$3F,d1          ; Mask directional buttons
ROM:000003AE                 or.b    d1,d0            ; Combine button states
ROM:000003B0                 not.b   d0               ; Invert for active-high logic
ROM:000003B2                 move.w  d0,(Controller1Input).l ; Store controller 1 input
ROM:000003B8                 move.b  #$40,(IO_CT2_CTRL+1).l ; Set controller 2 control port
ROM:000003C0                 move.w  #$A,d1           ; Set delay counter
ROM:000003C4 DelayController2Read:                  ; CODE XREF: ReadControllerInput:DelayController2Read↓j
ROM:000003C4                 dbf     d1,DelayController2Read ; Delay loop
ROM:000003C8                 move.b  #0,(IO_CT2_DATA+1).l ; Clear controller 2 data
ROM:000003D0                 move.w  #$A,d1           ; Set delay counter
ROM:000003D4 DelayController2SecondRead:            ; CODE XREF: ReadControllerInput:DelayController2SecondRead↓j
ROM:000003D4                 dbf     d1,DelayController2SecondRead ; Delay loop
ROM:000003D8                 move.b  (IO_CT2_DATA+1).l,d0 ; Read controller 2 data
ROM:000003DE                 asl.b   #2,d0            ; Shift bits for button mask
ROM:000003E0                 andi.b  #$C0,d0          ; Mask Start/A buttons
ROM:000003E4                 move.b  #$40,(IO_CT2_DATA+1).l ; Set controller 2 data
ROM:000003EC                 move.w  #$A,d1           ; Set delay counter
ROM:000003F0 DelayController2ThirdRead:             ; CODE XREF: ReadControllerInput:DelayController2ThirdRead↓j
ROM:000003F0                 dbf     d1,DelayController2ThirdRead ; Delay loop
ROM:000003F4                 move.b  (IO_CT2_DATA+1).l,d1 ; Read controller 2 data
ROM:000003FA                 andi.b  #$3F,d1          ; Mask directional buttons
ROM:000003FE                 or.b    d1,d0            ; Combine button states
ROM:00000400                 not.b   d0               ; Invert for active-high logic
ROM:00000402                 move.w  d0,(Controller2Input).l ; Store controller 2 input
ROM:00000408                 move.w  d0,d1            ; Copy controller 2 input
ROM:0000040A                 move.w  (Controller1Input).l,d0 ; Load controller 1 input
ROM:00000410                 rts                      ; Return
ROM:00000410 ; End of function ReadControllerInput

; ===========================================================================
; AdjustWordmarkPosition: Adjusts wordmark sprite positions
; Manipulates sprite positions for the sliding "ELECTRONIC ARTS" wordmark
; during the animation, based on the current frame.
; ===========================================================================
ROM:00000412 AdjustWordmarkPosition:                ; CODE XREF: AnimateEALogo:SetupALetter↓p
ROM:00000412                 moveq   #$FFFFFFFC,d2    ; Set negative offset for sliding
ROM:00000414                 muls.w  d1,d2            ; Scale offset by animation frame
ROM:00000416                 moveq   #8,d0            ; Set loop counter (8 iterations)
ROM:00000418 UpdateWordmarkSprite:                  ; CODE XREF: AdjustWordmarkPosition+10↓j
ROM:00000418                 add.w   d2,(a0)          ; Adjust sprite position
ROM:0000041A                 move.w  (a0)+,(a5)       ; Write position to VDP data
ROM:0000041C                 add.w   d2,(a0)          ; Adjust next sprite position
ROM:0000041E                 move.w  (a0)+,(a5)       ; Write position to VDP data
ROM:00000420                 add.w   d1,d2            ; Increment offset for next iteration
ROM:00000422                 dbf     d0,UpdateWordmarkSprite ; Loop for 8 iterations
ROM:00000426                 rts                      ; Return
ROM:00000426 ; End of function AdjustWordmarkPosition

; ===========================================================================
; UpdateSpritePalette: Updates sprite palette for color changes
; Changes sprite palette indices to transition colors (green to yellow to blue)
; for the ECA letters and wordmark during the animation.
; ===========================================================================
ROM:00000428 UpdateSpritePalette:                   ; CODE XREF: AnimateEALogo:SetupELetter↓p
ROM:00000428                                         ; AnimateEALogo:SetupCLetter↓p
ROM:00000428                 moveq   #$11,d0          ; Set loop counter (18 sprites)
ROM:0000042A ProcessSpritePalette:                  ; CODE XREF: UpdateSpritePalette+C↓j
ROM:0000042A                 move.w  (a0)+,d2         ; Read sprite attribute
ROM:0000042C                 andi.w  #$EFFF,d2        ; Clear palette index bits
ROM:00000430                 or.w    d1,d2            ; Set new palette index (color)
ROM:00000432                 move.w  d2,(a5)          ; Write to VDP data
ROM:00000434                 dbf     d0,ProcessSpritePalette ; Loop for 18 sprites
ROM:00000438                 rts                      ; Return
ROM:00000438 ; End of function UpdateSpritePalette

; ===========================================================================
; PositionELetter: Adjusts sprite positions for E letter
; Sets sprite positions for the green E letter as it flips into place.
; ===========================================================================
ROM:0000043A PositionELetter:                       ; CODE XREF: AnimateEALogo+2EC↓p
ROM:0000043A                 movem.w d0-d7,-(sp)      ; Save registers
ROM:0000043E                 move.w  d3,d4            ; Copy base position
ROM:00000440                 addi.w  #$20,d3          ; Add offset for right side
ROM:00000444                 moveq   #$20,d5          ; Set width (32 pixels)
ROM:00000446                 sub.w   d1,d5            ; Adjust for animation frame
ROM:00000448                 asr.w   #1,d5            ; Divide by 2 for centering
ROM:0000044A                 add.w   d5,d4            ; Adjust left position
ROM:0000044C                 sub.w   d5,d3            ; Adjust right position
ROM:0000044E                 addi.w  #$80,d4          ; Add screen offset (left)
ROM:00000452                 addi.w  #$80,d3          ; Add screen offset (right)
ROM:00000456                 moveq   #8,d0            ; Set loop counter (9 sprites)
ROM:00000458 WriteELetterPositions:                 ; CODE XREF: PositionELetter+22↓j
ROM:00000458                 move.w  d4,(a5)          ; Write left position to VDP
ROM:0000045A                 move.w  d3,(a5)          ; Write right position to VDP
ROM:0000045C                 dbf     d0,WriteELetterPositions ; Loop for 9 sprites
ROM:00000460                 movem.w (sp)+,d0-d7      ; Restore registers
ROM:00000464                 rts                      ; Return
ROM:00000464 ; End of function PositionELetter

; ===========================================================================
; PositionALetter: Adjusts sprite positions for A letter
; Sets sprite positions for the blue A letter as it flips into place.
; ===========================================================================
ROM:00000466 PositionALetter:                       ; CODE XREF: AnimateEALogo+32A↓p
ROM:00000466                 movem.w d0-d7,-(sp)      ; Save registers
ROM:0000046A                 move.w  d3,d4            ; Copy base position
ROM:0000046C                 addi.w  #$20,d3          ; Add offset for right side
ROM:00000470                 addi.w  #$80,d4          ; Add screen offset (left)
ROM:00000474                 addi.w  #$80,d3          ; Add screen offset (right)
ROM:00000478                 moveq   #8,d0            ; Set loop counter (9 sprites)
ROM:0000047A WriteALetterPositions:                 ; CODE XREF: PositionALetter+18↓j
ROM:0000047A                 move.w  d4,(a5)          ; Write left position to VDP
ROM:0000047C                 move.w  d3,(a5)          ; Write right position to VDP
ROM:0000047E                 dbf     d0,WriteALetterPositions ; Loop for 9 sprites
ROM:00000482                 movem.w (sp)+,d0-d7      ; Restore registers
ROM:00000486                 rts                      ; Return
ROM:00000486 ; End of function PositionALetter

; ===========================================================================
; UpdateSpriteTiles: Updates sprite tile indices
; Updates tile indices for the ECA letters and wordmark during animation.
; ===========================================================================
ROM:00000488 UpdateSpriteTiles:                     ; CODE XREF: AnimateEALogo+300↓p
ROM:00000488                                         ; AnimateEALogo+340↓p ...
ROM:00000488                 movem.w d1-d3,-(sp)      ; Save registers
ROM:0000048C                 ori.w   #$C00,d2         ; Set high-priority sprite flag
ROM:00000490                 ori.w   #$C00,d3         ; Set high-priority sprite flag
ROM:00000494                 bra.s   WriteSpriteTileIndices ; Jump to loop
ROM:00000496 WriteTileIndex:                        ; CODE XREF: UpdateSpriteTiles:WriteSpriteTileIndices↓j
ROM:00000496                 move.w  d2,(a5)          ; Write tile index to VDP
ROM:00000498                 addq.w  #1,d2            ; Increment tile index
ROM:0000049A                 move.w  d2,(a5)          ; Write next tile index
ROM:0000049C                 addq.w  #1,d2            ; Increment tile index
ROM:0000049E WriteSpriteTileIndices:                ; CODE XREF: UpdateSpriteTiles+C↑j
ROM:0000049E                 dbf     d1,WriteTileIndex ; Loop for d1 iterations
ROM:000004A2                 move.w  d2,(a5)          ; Write final tile index
ROM:000004A4                 move.w  d3,(a5)          ; Write final tile index
ROM:000004A6                 movem.w (sp)+,d1-d3      ; Restore registers
ROM:000004AA                 rts                      ; Return
ROM:000004AA ; End of function UpdateSpriteTiles

; ===========================================================================
; AnimateEALogo: Main EA logo animation routine
; Orchestrates the flipping of ECA letters and sliding of the wordmark, handling
; sprite positions, palette changes, and animation timing.
; ===========================================================================
ROM:000004AC AnimateEALogo:                         ; CODE XREF: EALogoEntry+15E↑p
ROM:000004AC                 tst.w   (AnimationCompleteFlag).l ; Check if animation is complete
ROM:000004B2                 bne.s   ExitAnimation         ; Exit if complete
ROM:000004B4                 tst.w   (AnimationFrameCounter).l ; Check animation frame counter
ROM:000004BA                 blt.w   UpdateAnimationTimer   ; Skip if negative
ROM:000004BE                 move.w  (AnimationFrameCounter).l,d0 ; Load frame counter
ROM:000004C4                 subq.w  #1,(AnimationFrameCounter).l ; Decrement frame counter
ROM:000004CA                 move.w  d0,d1            ; Copy frame counter
ROM:000004CC                 neg.w   d0               ; Negate for sliding effect
ROM:000004CE                 move.l  #$60000000,(VDP_CTRL).l ; Set VDP to sprite table
ROM:000004D8                 moveq   #$6F,d2          ; Set loop counter (112 sprites)
ROM:000004DA WriteSpritePositions:                  ; CODE XREF: AnimateEALogo+3A↓j
ROM:000004DA                 move.w  d0,(a5)          ; Write sprite Y position
ROM:000004DC                 move.w  #$140,(a5)       ; Write sprite size/link
ROM:000004E0                 move.w  d1,(a5)          ; Write sprite X position
ROM:000004E2                 move.w  #$140,(a5)       ; Write sprite tile index
ROM:000004E6                 dbf     d2,WriteSpritePositions ; Loop for 112 sprites
ROM:000004EA UpdateAnimationTimer:                  ; CODE XREF: AnimateEALogo+E↑j
ROM:000004EA                 subq.w  #1,(AnimationTimer).l ; Decrement animation timer
ROM:000004F0                 bge.w   FinalizeAnimation     ; Skip if timer not expired
ROM:000004F4                 move.w  #1,(AnimationTimer).l ; Reset timer
ROM:000004FC                 tst.w   (AnimationPhase).l ; Check animation phase
ROM:00000502                 bne.s   AdvanceAnimationPhase  ; Skip if not initial phase
ROM:00000504                 tst.w   (AnimationFrameCounter).l ; Check frame counter
ROM:0000050A                 bge.s   AdvanceAnimationPhase  ; Skip if not negative
ROM:0000050C                 st      (AnimationCompleteFlag).l ; Mark animation complete
ROM:00000512 ExitAnimation:                         ; CODE XREF: AnimateEALogo+6↑j
ROM:00000512                 moveq   #$FFFFFFFF,d0    ; Set return value
ROM:00000514                 rts                      ; Return
ROM:00000516 AdvanceAnimationPhase:                 ; CODE XREF: AnimateEALogo+56↑j
ROM:00000516                                         ; AnimateEALogo+5E↑j
ROM:00000516                 addq.w  #1,(AnimationPhase).l ; Increment animation phase
ROM:0000051C                 move.w  (AnimationPhase).l,d7 ; Load animation phase
ROM:00000522                 lea     (AnimationDataBuffer).l,a3 ; Load animation data
ROM:00000528                 move.w  #$23F,d0         ; Set loop counter (576 longs)
ROM:0000052C                 move.l  #$49200001,(VDP_CTRL).l ; Set VDP to VRAM
ROM:00000536 TransferAnimationData:                 ; CODE XREF: AnimateEALogo+8C↓j
ROM:00000536                 move.l  (a3)+,(a5)       ; Write animation data to VDP
ROM:00000538                 dbf     d0,TransferAnimationData ; Loop for 576 longs
ROM:0000053C                 cmp.w   #$18,d7          ; Check if phase > 24
ROM:00000540                 ble.s   SetupLetterAnimation  ; Continue if <= 24
ROM:00000542                 clr.w   (AnimationPhase).l ; Reset animation phase
ROM:00000548                 addq.w  #1,(LetterCounter).l ; Increment letter counter (E, C, A)
ROM:0000054E                 cmpi.w  #2,(LetterCounter).l ; Check if all letters done
ROM:00000556                 ble.w   FinalizeAnimation     ; Continue if not
ROM:0000055A                 clr.w   (LetterCounter).l ; Reset letter counter
ROM:00000560                 move.w  #$50,(AnimationTimer).l ; Set fade-out timer
ROM:00000568                 bra.w   FinalizeAnimation     ; Jump to end
ROM:0000056C SetupLetterAnimation:                  ; CODE XREF: AnimateEALogo+94↑j
ROM:0000056C                 move.l  #$40000003,(VDP_CTRL).l ; Set VDP to CRAM
ROM:00000576                 move.w  #$8F08,(a4)      ; Set auto-increment
ROM:0000057A                 cmp.w   #$D,d7           ; Check if phase >= 13
ROM:0000057E                 bge.w   HandleColorChange     ; Handle color change
ROM:00000582                 cmp.w   #7,d7            ; Check if phase == 7
ROM:00000586                 bne.w   SetPaletteFlag        ; Skip if not
ROM:0000058A                 move.w  #$1000,d1        ; Set palette index (green)
ROM:0000058E                 cmpi.w  #0,(LetterCounter).l ; Check if E letter
ROM:00000596                 bne.s   SetupCLetter          ; Handle C or A
ROM:00000598                 move.l  #$C00C0000,(VDP_CTRL).l ; Set VRAM address for E
ROM:000005A2                 move.w  #$A0,(a5)        ; Write tile index (E)
ROM:000005A6                 move.l  #$C0080000,(VDP_CTRL).l ; Set VRAM address
ROM:000005B0                 move.w  #$A0,(a5)        ; Write tile index
ROM:000005B4                 move.l  #$C00A0000,(VDP_CTRL).l ; Set VRAM address
ROM:000005BE                 move.w  #$4E4,(a5)       ; Write tile index (green E)
ROM:000005C2                 lea     (ELetterSpriteData).l,a0 ; Load E sprite data
ROM:000005C8                 move.w  #$5C04,(VDP_CTRL).l ; Set sprite table address
ROM:000005D0                 bra.s   SetupELetter          ; Update palette
ROM:000005D2 SetupCLetter:                          ; CODE XREF: AnimateEALogo+EA↑j
ROM:000005D2                 cmpi.w  #1,(LetterCounter).l ; Check if C letter
ROM:000005DA                 bne.s   SetupALetter          ; Handle A
ROM:000005DC                 move.l  #$C0140000,(VDP_CTRL).l ; Set VRAM address for C
ROM:000005E6                 move.w  #$A42,(a5)       ; Write tile index (yellow C)
ROM:000005EA                 move.l  #$C01A0000,(VDP_CTRL).l ; Set VRAM address
ROM:000005F4                 move.w  #$A42,(a5)       ; Write tile index
ROM:000005F8                 move.l  #$C0060000,(VDP_CTRL).l ; Set VRAM address
ROM:00000602                 move.w  #$E86,(a5)       ; Write tile index (yellow C)
ROM:00000606                 lea     (CLetterSpriteData).l,a0 ; Load C sprite data
ROM:0000060C                 move.w  #$5C94,(VDP_CTRL).l ; Set sprite table address
ROM:00000614                 bra.s   SetupELetter          ; Update palette
ROM:00000616 SetupALetter:                          ; CODE XREF: AnimateEALogo+12E↑j
ROM:00000616                 move.l  #$C0160000,(VDP_CTRL).l ; Set VRAM address for A
ROM:00000620                 move.w  #$8A,(a5)        ; Write tile index (blue A)
ROM:00000624                 move.l  #$C01C0000,(VDP_CTRL).l ; Set VRAM address
ROM:0000062E                 move.w  #$8A,(a5)        ; Write tile index
ROM:00000632                 move.l  #$C0040000,(VDP_CTRL).l ; Set VRAM address
ROM:0000063C                 move.w  #$CE,(a5)        ; Write tile index (blue A)
ROM:00000640                 lea     (ALetterSpriteData).l,a0 ; Load A sprite data
ROM:00000646                 move.w  #$5D24,(VDP_CTRL).l ; Set sprite table address
ROM:0000064E SetupELetter:                          ; CODE XREF: AnimateEALogo+124↑j
ROM:0000064E                                         ; AnimateEALogo+168↑j
ROM:0000064E                 bsr.w   UpdateSpritePalette ; Update sprite palette
ROM:00000652 SetPaletteFlag:                        ; CODE XREF: AnimateEALogo+DA↑j
ROM:00000652                 moveq   #$FFFFFFFF,d1    ; Set palette flag
ROM:00000654                 bra.w   ConfigureLetterSprites ; Continue animation
ROM:00000658 HandleColorChange:                     ; CODE XREF: AnimateEALogo+D2↑j
ROM:00000658                 cmp.w   #$14,d7          ; Check if phase == 20
ROM:0000065C                 bne.w   SetAlternatePaletteFlag ; Skip if not
ROM:00000660                 moveq   #0,d1            ; Clear palette index
ROM:00000662                 cmpi.w  #0,(LetterCounter).l ; Check if E letter
ROM:0000066A                 bne.s   UpdateCLetter         ; Handle C or A
ROM:0000066C                 move.l  #$C00C0000,(VDP_CTRL).l ; Set VRAM address for E
ROM:00000676                 move.w  #$4E4,(a5)       ; Write tile index (green E)
ROM:0000067A                 move.l  #$C0080000,(VDP_CTRL).l ; Set VRAM address
ROM:00000684                 move.w  #$8E8,(a5)       ; Write tile index
ROM:00000688                 move.l  #$C00A0000,(VDP_CTRL).l ; Set VRAM address
ROM:00000692                 move.w  #$A0,(a5)        ; Write tile index
ROM:00000696                 lea     (ELetterSpriteData).l,a0 ; Load E sprite data
ROM:0000069C                 move.w  #$5C04,(VDP_CTRL).l ; Set sprite table address
ROM:000006A4                 bra.s   UpdateELetter         ; Update palette
ROM:000006A6 UpdateCLetter:                        ; CODE XREF: AnimateEALogo+1BE↑j
ROM:000006A6                 cmpi.w  #1,(LetterCounter).l ; Check if C letter
ROM:000006AE                 bne.s   UpdateALetter         ; Handle A
ROM:000006B0                 move.l  #$C0140000,(VDP_CTRL).l ; Set VRAM address for C
ROM:000006BA                 move.w  #$E86,(a5)       ; Write tile index (yellow C)
ROM:000006BE                 move.l  #$C01A0000,(VDP_CTRL).l ; Set VRAM address
ROM:000006C8                 move.w  #$ECA,(a5)       ; Write tile index
ROM:000006CC                 move.l  #$C0060000,(VDP_CTRL).l ; Set VRAM address
ROM:000006D6                 move.w  #$A42,(a5)       ; Write tile index
ROM:000006DA                 lea     (CLetterSpriteData).l,a0 ; Load C sprite data
ROM:000006E0                 move.w  #$5C94,(VDP_CTRL).l ; Set sprite table address
ROM:000006E8                 bra.s   UpdateELetter         ; Update palette
ROM:000006EA UpdateALetter:                        ; CODE XREF: AnimateEALogo+202↑j
ROM:000006EA                 move.l  #$C0160000,(VDP_CTRL).l ; Set VRAM address for A
ROM:000006F4                 move.w  #$CE,(a5)        ; Write tile index (blue A)
ROM:000006F8                 move.l  #$C01C0000,(VDP_CTRL).l ; Set VRAM address
ROM:00000702                 move.w  #$8EE,(a5)       ; Write tile index
ROM:00000706                 move.l  #$C0040000,(VDP_CTRL).l ; Set VRAM address
ROM:00000710                 move.w  #$8A,(a5)        ; Write tile index
ROM:00000714                 lea     (ALetterSpriteData).l,a0 ; Load A sprite data
ROM:0000071A                 move.w  #$5D24,(VDP_CTRL).l ; Set sprite table address
ROM:00000722 UpdateELetter:                        ; CODE XREF: AnimateEALogo+1F8↑j
ROM:00000722                                         ; AnimateEALogo+23C↑j
ROM:00000722                 bsr.w   UpdateSpritePalette ; Update sprite palette
ROM:00000726 SetAlternatePaletteFlag:               ; CODE XREF: AnimateEALogo+1B0↑j
ROM:00000726                 moveq   #1,d1            ; Set alternate palette flag
ROM:00000728 ConfigureLetterSprites:                ; CODE XREF: AnimateEALogo+1A8↑j
ROM:00000728                 cmpi.w  #0,(LetterCounter).l ; Check if E letter
ROM:00000730                 bne.s   ConfigureCLetter      ; Handle C or A
ROM:00000732                 move.w  #$5C00,(VDP_CTRL).l ; Set sprite table for E
ROM:0000073A                 movea.l #ELetterWordmarkData,a0 ; Load E wordmark data
ROM:00000740 ConfigureCLetter:                      ; CODE XREF: AnimateEALogo+284↑j
ROM:00000740                 cmpi.w  #1,(LetterCounter).l ; Check if C letter
ROM:00000748                 bne.s   ConfigureALetter      ; Handle A
ROM:0000074A                 move.w  #$5C90,(VDP_CTRL).l ; Set sprite table for C
ROM:00000752                 lea     (CLetterWordmarkData).l,a0 ; Load C wordmark data
ROM:00000758 ConfigureALetter:                      ; CODE XREF: AnimateEALogo+29C↑j
ROM:00000758                 cmpi.w  #2,(LetterCounter).l ; Check if A letter
ROM:00000760                 bne.s   UpdateWordmark        ; Skip if not
ROM:00000762                 move.w  #$5D20,(VDP_CTRL).l ; Set sprite table for A
ROM:0000076A                 lea     (ALetterWordmarkData).l,a0 ; Load A wordmark data
ROM:00000770 UpdateWordmark:                        ; CODE XREF: AnimateEALogo+2B4↑j
ROM:00000770                 bsr.w   AdjustWordmarkPosition ; Update wordmark positions
ROM:00000774                 move.w  d7,d1            ; Copy animation phase
ROM:00000776                 ext.l   d1               ; Extend to long
ROM:00000778                 divu.w  #3,d1            ; Divide by 3 for timing
ROM:0000077C                 cmpi.w  #0,(LetterCounter).l ; Check if E letter
ROM:00000784                 bne.s   ProcessALetter        ; Handle C or A
ROM:00000786                 move.w  d1,-(sp)         ; Save d1
ROM:00000788                 asl.w   #2,d1            ; Scale animation phase
ROM:0000078A                 move.w  #$68,d3          ; Set base Y position
ROM:0000078E                 sub.w   d7,d3            ; Adjust for animation
ROM:00000790                 move.w  #$5C06,(VDP_CTRL).l ; Set sprite table for E
ROM:00000798                 bsr.w   PositionELetter  ; Adjust E letter position
ROM:0000079C                 move.w  (sp)+,d1         ; Restore d1
ROM:0000079E                 moveq   #1,d2            ; Set tile index offset
ROM:000007A0                 moveq   #$12,d3          ; Set tile index
ROM:000007A2                 moveq   #0,d3            ; Clear d3
ROM:000007A4                 move.w  #$5C02,(VDP_CTRL).l ; Set sprite table
ROM:000007AC                 bsr.w   UpdateSpriteTiles ; Update sprite tiles
ROM:000007B0                 move.w  #$4E4,d0         ; Set tile index (green E)
ROM:000007B4                 bsr.w   UpdateLetterColor ; Update color
ROM:000007B8                 bra.s   FinalizeLetterAnimation ; Continue
ROM:000007BA ProcessALetter:                        ; CODE XREF: AnimateEALogo+2D8↑j
ROM:000007BA                 cmpi.w  #2,(LetterCounter).l ; Check if A letter
ROM:000007C2                 bne.s   ProcessCLetter        ; Handle C
ROM:000007C4                 move.w  d1,-(sp)         ; Save d1
ROM:000007C6                 asl.w   #2,d1            ; Scale animation phase
ROM:000007C8                 move.w  #$98,d3          ; Set base Y position
ROM:000007CC                 add.w   d7,d3            ; Adjust for animation
ROM:000007CE                 move.w  #$5D26,(VDP_CTRL).l ; Set sprite table for A
ROM:000007D6                 bsr.w   PositionALetter  ; Adjust A letter position
ROM:000007DA                 move.w  (sp)+,d1         ; Restore d1
ROM:000007DC                 move.w  #$5D1A,(VDP_CTRL).l ; Set sprite table
ROM:000007E4                 move.w  #$C24,(a5)       ; Write tile index
ROM:000007E8                 moveq   #$25,d2          ; Set tile index offset
ROM:000007EA                 moveq   #0,d3            ; Clear d3
ROM:000007EC                 bsr.w   UpdateSpriteTiles ; Update sprite tiles
ROM:000007F0                 move.w  #$CE,d0          ; Set tile index (blue A)
ROM:000007F4                 bsr.w   UpdateLetterColor ; Update color
ROM:000007F8 FinalizeLetterAnimation:               ; CODE XREF: AnimateEALogo+30C↑j
ROM:000007F8                 bra.s   FinalizeAnimation ; Continue
ROM:000007FA ProcessCLetter:                        ; CODE XREF: AnimateEALogo+316↑j
ROM:000007FA                 move.w  #$5C8A,(VDP_CTRL).l ; Set sprite table for C
ROM:00000802                 move.w  #$C12,(a5)       ; Write tile index
ROM:00000806                 moveq   #$13,d2          ; Set tile index offset
ROM:00000808                 moveq   #0,d3            ; Clear d3
ROM:0000080A                 bsr.w   UpdateSpriteTiles ; Update sprite tiles
ROM:0000080E                 move.w  #$E86,d0         ; Set tile index (yellow C)
ROM:00000812                 bsr.w   UpdateLetterColor ; Update color
ROM:00000816                 lea     (AnimationDataBuffer).l,a3 ; Load fade data
ROM:0000081C                 moveq   #0,d2            ; Clear d2
ROM:0000081E                 move.w  #$23F,d0         ; Set loop counter (576 longs)
ROM:00000822 ClearFadeData:                         ; CODE XREF: AnimateEALogo+378↓j
ROM:00000822                 move.l  d2,(a3)+         ; Clear fade data
ROM:00000824                 dbf     d0,ClearFadeData ; Loop for 576 longs
ROM:00000828                 add.w   d1,d1            ; Scale animation phase
ROM:0000082A                 addq.w  #4,d1            ; Adjust phase
ROM:0000082C                 cmp.w   #$10,d1          ; Check if phase > 16
ROM:00000830                 ble.s   SetupWordmarkFade     ; Continue if <= 16
ROM:00000832                 moveq   #$10,d1          ; Cap phase at 16
ROM:00000834 SetupWordmarkFade:                    ; CODE XREF: AnimateEALogo+384↑j
ROM:00000834                 moveq   #$20,d3          ; Set width (32 pixels)
ROM:00000836                 movea.w d3,a1            ; Copy width
ROM:00000838                 subq.w  #1,a1            ; Adjust width
ROM:0000083A                 move.w  #$10,d0          ; Set max phase
ROM:0000083E                 sub.w   d1,d0            ; Adjust for current phase
ROM:00000840                 add.w   d0,d3            ; Adjust width
ROM:00000842                 suba.w  d0,a1            ; Adjust width
ROM:00000844                 bsr.w   FadeWordmark      ; Update wordmark fade
ROM:00000848 FinalizeAnimation:                     ; CODE XREF: AnimateEALogo+44↑j
ROM:00000848                                         ; AnimateEALogo+AA↑j ...
ROM:00000848                 move.w  #$8F02,(a4)      ; Restore auto-increment
ROM:0000084C                 moveq   #0,d0            ; Clear return value
ROM:0000084E                 rts                      ; Return
ROM:0000084E ; End of function AnimateEALogo

; ===========================================================================
; UpdateWordmarkSprite: Updates wordmark sprite position and tiles
; Updates sprite positions and tile indices for the sliding wordmark.
; ===========================================================================
ROM:00000850 UpdateWordmarkSpriteData:                  ; CODE XREF: SetupWordmarkSprites:WriteSpriteData↓p
ROM:00000850                                         ; SetupWordmarkSprites+6↓p ...
ROM:00000850                 move.w  #$80,(a0)        ; Set base X position
ROM:00000854                 add.w   d3,(a0)          ; Adjust X position
ROM:00000856                 move.w  (a0)+,(a5)       ; Write X position to VDP
ROM:00000858                 move.w  #$C00,d0         ; Set tile flag
ROM:0000085C                 or.w    d1,d0            ; Add tile index
ROM:0000085E                 addq.w  #1,d1            ; Increment tile index
ROM:00000860                 move.w  d0,(a5)          ; Write tile index to VDP
ROM:00000862                 move.w  #$8201,(a1)      ; Set base Y position
ROM:00000866                 add.w   d4,(a1)          ; Adjust Y position
ROM:00000868                 addq.w  #4,d4            ; Increment Y offset
ROM:0000086A                 move.w  (a1)+,(a5)       ; Write Y position to VDP
ROM:0000086C                 move.w  #$80,d0          ; Set base tile index
ROM:00000870                 add.w   d2,d0            ; Add tile offset
ROM:00000872                 rts                      ; Return
ROM:00000872 ; End of function UpdateWordmarkSprite

; ===========================================================================
; SetupWordmarkSprites: Sets up wordmark sprite data
; Configures sprite data for the "ELECTRONIC ARTS" wordmark sliding effect.
; ===========================================================================
ROM:00000874 SetupWordmarkSprites:                  ; CODE XREF: EALogoGraphicsInit+16E↓p
ROM:00000874                                         ; EALogoGraphicsInit+18C↓p ...
ROM:00000874                 moveq   #7,d7            ; Set loop counter (8 iterations)
ROM:00000876 WriteSpriteData:                       ; CODE XREF: SetupWordmarkSprites+10↓j
ROM:00000876                 bsr.s   UpdateWordmarkSpriteData ; Update sprite
ROM:00000878                 move.w  d0,(a5)          ; Write tile index
ROM:0000087A                 bsr.s   UpdateWordmarkSpriteData ; Update next sprite
ROM:0000087C                 addi.w  #$20,d0          ; Adjust tile index
ROM:00000880                 move.w  d0,(a5)          ; Write tile index
ROM:00000882                 addq.w  #6,d3            ; Adjust X position
ROM:00000884                 dbf     d7,WriteSpriteData ; Loop for 8 iterations
ROM:00000888                 bsr.s   UpdateWordmarkSpriteData ; Update final sprite
ROM:0000088A                 move.w  d0,(a5)          ; Write tile index
ROM:0000088C                 move.w  d5,d1            ; Copy tile index
ROM:0000088E                 bsr.s   UpdateWordmarkSpriteData ; Update final sprite
ROM:00000890                 addi.w  #$20,d0          ; Adjust tile index
ROM:00000894                 move.w  d0,(a5)          ; Write tile index
ROM:00000896                 rts                      ; Return
ROM:00000896 ; End of function SetupWordmarkSprites

; ===========================================================================
; CalculateWordmarkIndex: Calculates wordmark sprite indices
; Computes indices for wordmark sprite animation.
; ===========================================================================
ROM:00000898 CalculateWordmarkIndex:                ; CODE XREF: EALogoGraphicsInit:ProcessAnimationData↓p
ROM:00000898                                         ; EALogoGraphicsInit+5A↓p
ROM:00000898                 move.w  d5,d6            ; Copy base index
ROM:0000089A                 move.w  d4,d7            ; Copy offset
ROM:0000089C                 asl.w   #2,d7            ; Scale offset
ROM:0000089E                 add.w   d7,d6            ; Add to index
ROM:000008A0                 rts                      ; Return
ROM:000008A0 ; End of function CalculateWordmarkIndex

; ===========================================================================
; PrepareAnimationData: Prepares sprite animation data
; Prepares data for sprite animation calculations.
; ===========================================================================
ROM:000008A2 PrepareAnimationData:                  ; CODE XREF: ProcessSpriteAnimation+A↓p
ROM:000008A2                                         ; ProcessSpriteAnimation+1A↓p
ROM:000008A2                 move.l  (AnimationMask).l,d3 ; Load animation mask
ROM:000008A8                 move.l  d0,d5            ; Copy input
ROM:000008AA                 swap    d5               ; Swap words
ROM:000008AC                 move.w  d5,d4            ; Copy high word
ROM:000008AE                 andi.w  #7,d5            ; Mask low bits
ROM:000008B2                 asl.w   #2,d5            ; Scale for bit shift
ROM:000008B4                 asr.w   #3,d4            ; Shift for tile index
ROM:000008B6                 asl.w   #5,d4            ; Scale for VRAM offset
ROM:000008B8                 rts                      ; Return
ROM:000008B8 ; End of function PrepareAnimationData

; ===========================================================================
; ProcessSpriteAnimation: Processes sprite animation data
; Handles sprite animation data for smooth transitions in the logo animation.
; ===========================================================================
ROM:000008BA ProcessSpriteAnimation:                ; CODE XREF: FadeWordmark+72↓p
ROM:000008BA                                         ; FadeWordmark+90↓p ...
ROM:000008BA                 movem.l d0-d7,-(sp)      ; Save registers
ROM:000008BE                 cmp.l   d1,d2            ; Compare animation bounds
ROM:000008C0                 blt.s   ExitSpriteAnimation   ; Skip if out of bounds
ROM:000008C2                 move.l  d2,d0            ; Copy bound
ROM:000008C4                 bsr.s   PrepareAnimationData ; Prepare data
ROM:000008C6                 move.l  d3,d6            ; Copy mask
ROM:000008C8                 move.w  d4,d7            ; Copy tile offset
ROM:000008CA                 subi.w  #$1C,d5          ; Adjust shift
ROM:000008CE                 neg.w   d5               ; Negate shift
ROM:000008D0                 asl.l   d5,d6            ; Shift mask
ROM:000008D2                 move.l  d1,d0            ; Copy lower bound
ROM:000008D4                 bsr.s   PrepareAnimationData ; Prepare data
ROM:000008D6                 lsr.l   d5,d3            ; Shift mask
ROM:000008D8                 cmp.w   d7,d4            ; Compare tile offsets
ROM:000008DA                 bne.s   WriteTileMask         ; Handle different tiles
ROM:000008DC                 and.l   d3,d6            ; Combine masks
ROM:000008DE                 move.l  d6,(a6,d4.w)     ; Write to VRAM
ROM:000008E2                 bra.s   ExitSpriteAnimation   ; Continue
ROM:000008E4 WriteTileMask:                         ; CODE XREF: ProcessSpriteAnimation+20↑j
ROM:000008E4                 move.l  d3,(a6,d4.w)     ; Write mask to VRAM
ROM:000008E8 AdjustTileOffset:                      ; CODE XREF: ProcessSpriteAnimation+3E↓j
ROM:000008E8                 addi.w  #$20,d4          ; Increment tile offset
ROM:000008EC                 cmp.w   d4,d7            ; Check if done
ROM:000008EE                 beq.s   WriteFinalMask        ; Exit loop
ROM:000008F0                 move.l  (AnimationMask).l,(a6,d4.w) ; Write default mask
ROM:000008F8                 bra.s   AdjustTileOffset      ; Continue loop
ROM:000008FA WriteFinalMask:                        ; CODE XREF: ProcessSpriteAnimation+34↑j
ROM:000008FA                 move.l  d6,(a6,d7.w)     ; Write final mask
ROM:000008FE ExitSpriteAnimation:                   ; CODE XREF: ProcessSpriteAnimation+6↑j
ROM:000008FE                                         ; ProcessSpriteAnimation+28↑j
ROM:000008FE                 movem.l (sp)+,d0-d7      ; Restore registers
ROM:00000902                 rts                      ; Return
ROM:00000902 ; End of function ProcessSpriteAnimation

; ===========================================================================
; UpdateLetterColor: Updates color for ECA letters
; Updates colors for the ECA letters during flipping and fading.
; ===========================================================================
ROM:00000904 UpdateLetterColor:                     ; CODE XREF: AnimateEALogo+308↑p
ROM:00000904                                         ; AnimateEALogo+348↑p ...
ROM:00000904                 cmp.w   #$18,d7          ; Check if phase == 24
ROM:00000908                 bne.s   ExitColorUpdate       ; Return if not
ROM:0000090A                 move.l  #$C0120000,(VDP_CTRL).l ; Set VRAM address
ROM:00000914                 move.w  d0,(a5)          ; Write tile index
ROM:00000916                 move.l  #$C0020000,(VDP_CTRL).l ; Set VRAM address
ROM:00000920                 cmp.w   #$E86,d0         ; Check if yellow C
ROM:00000924                 bne.s   AdjustColorIndex      ; Skip if not
ROM:00000926                 move.w  #$E22,d0         ; Adjust tile index
ROM:0000092A AdjustColorIndex:                      ; CODE XREF: UpdateLetterColor+20↑j
ROM:0000092A                 andi.w  #$666,d0         ; Mask color bits
ROM:0000092E                 move.w  d0,(a5)          ; Write color
ROM:00000930 ExitColorUpdate:                       ; CODE XREF: UpdateLetterColor+4↑j
ROM:00000930                 rts                      ; Return
ROM:00000930 ; End of function UpdateLetterColor

; ===========================================================================
; FadeWordmark: Handles wordmark fade-out effect
; Manages the fading out of the "ELECTRONIC ARTS" wordmark after animation.
; ===========================================================================
ROM:00000932 FadeWordmark:                         ; CODE XREF: AnimateEALogo+398↑p
ROM:00000932                 lea     WordmarkAnimationTable(pc),a0 ; Load animation table
ROM:00000936                 lea     (AnimationDataBuffer).l,a6 ; Load VRAM buffer
ROM:0000093C                 lea     WordmarkFadeTable(pc),a2 ; Load fade data
ROM:00000940                 lea     WordmarkPositionTable(pc),a3 ; Load position data
ROM:00000944                 moveq   #0,d6            ; Clear counter
ROM:00000946                 moveq   #8,d4            ; Set loop counter (9 iterations)
ROM:00000948 ProcessFadeStep:                       ; CODE XREF: FadeWordmark+A2↓j
ROM:00000948                 move.b  (a0)+,d5         ; Read animation step
ROM:0000094A                 ext.w   d5               ; Extend to word
ROM:0000094C                 moveq   #5,d0            ; Set inner loop counter
ROM:0000094E ProcessFadeIteration:                  ; CODE XREF: FadeWordmark+98↓j
ROM:0000094E                 move.l  #$AAAAAAAA,(AnimationMask).l ; Set default mask
ROM:00000958                 cmp.w   #$1B,d6          ; Check animation progress
ROM:0000095C                 beq.s   AdjustFadePosition    ; Skip if at midpoint
ROM:0000095E                 bgt.s   ReverseFadePosition   ; Handle reverse
ROM:00000960                 move.b  (a3)+,d7         ; Read forward position
ROM:00000962                 bra.s   AdjustFadePosition    ; Continue
ROM:00000964 ReverseFadePosition:                   ; CODE XREF: FadeWordmark+2C↑j
ROM:00000964                 move.b  -(a3),d7         ; Read reverse position
ROM:00000966                 neg.b   d7               ; Negate position
ROM:00000968 AdjustFadePosition:                    ; CODE XREF: FadeWordmark+2A↑j
ROM:00000968                                         ; FadeWordmark+30↑j
ROM:00000968                 ext.w   d7               ; Extend to word
ROM:0000096A                 sub.w   d7,d3            ; Adjust position
ROM:0000096C                 adda.w  d7,a1            ; Adjust pointer
ROM:0000096E                 addq.w  #1,d6            ; Increment counter
ROM:00000970                 tst.w   d5               ; Check animation step
ROM:00000972                 ble.s   HandleZeroStep        ; Handle zero/negative
ROM:00000974                 cmp.w   #1,d5            ; Check if step == 1
ROM:00000978                 bne.s   SetupFadeData         ; Skip if not
ROM:0000097A                 move.l  #$33333333,(AnimationMask).l ; Set fade mask
ROM:00000984 SetupFadeData:                         ; CODE XREF: FadeWordmark+46↑j
ROM:00000984                 move.l  d3,d1            ; Copy position
ROM:00000986                 move.l  a1,d2            ; Copy pointer
ROM:00000988                 cmp.w   #5,d0            ; Check if final iteration
ROM:0000098C                 bne.s   ApplyFadeData         ; Skip if not
ROM:0000098E                 move.l  #$DDDDDDDD,(AnimationMask).l ; Set final mask
ROM:00000998                 cmp.w   #8,d1            ; Check position
ROM:0000099C                 bge.s   ApplyFadeData         ; Skip if >= 8
ROM:0000099E                 moveq   #8,d1            ; Set minimum position
ROM:000009A0 ApplyFadeData:                         ; CODE XREF: FadeWordmark+5A↑j
ROM:000009A0                                         ; FadeWordmark+6A↑j
ROM:000009A0                 swap    d1               ; Swap position
ROM:000009A2                 swap    d2               ; Swap pointer
ROM:000009A4                 bsr.w   ProcessSpriteAnimation ; Process animation data
ROM:000009A8                 bra.s   AdvanceFadeBuffer      ; Continue
ROM:000009AA HandleZeroStep:                        ; CODE XREF: FadeWordmark+40↑j
ROM:000009AA                 blt.s   AdvanceFadeBuffer      ; Skip if negative
ROM:000009AC                 move.l  #$33333333,(AnimationMask).l ; Set fade mask
ROM:000009B6                 move.l  d3,d1            ; Copy position
ROM:000009B8                 move.b  (a2)+,d2         ; Read fade offset
ROM:000009BA                 ext.w   d2               ; Extend to word
ROM:000009BC                 add.w   d1,d2            ; Add to position
ROM:000009BE                 swap    d1               ; Swap position
ROM:000009C0                 swap    d2               ; Swap offset
ROM:000009C2                 bsr.w   ProcessSpriteAnimation ; Process animation data
ROM:000009C6 AdvanceFadeBuffer:                     ; CODE XREF: FadeWordmark+76↑j
ROM:000009C6                                         ; FadeWordmark:HandleZeroStep↑j
ROM:000009C6                 addq.l  #4,a6            ; Advance VRAM buffer
ROM:000009C8                 subq.w  #1,d5            ; Decrement step
ROM:000009CA                 dbf     d0,ProcessFadeIteration ; Loop for 6 iterations
ROM:000009CE                 adda.l  #$E8,a6          ; Advance VRAM buffer
ROM:000009D4                 dbf     d4,ProcessFadeStep ; Loop for 9 iterations
ROM:000009D8                 rts                      ; Return
ROM:000009D8 ; End of function FadeWordmark

; ===========================================================================
; InitVDPForLogo: Initializes VDP for logo animation
; Sets up VDP registers and clears VRAM for the EA logo display.
; ===========================================================================
ROM:000009DA InitVDPForLogo:                       ; CODE XREF: EALogoEntry+10A↑p
ROM:000009DA                 clr.w   (AnimationCompleteFlag).l ; Clear animation flag
ROM:000009E0                 movea.l #VDP_CTRL,a4     ; Set VDP control port
ROM:000009E6                 movea.l #VDP_DATA,a5     ; Set VDP data port
ROM:000009EC                 move.w  #$3FF6,d0        ; Set loop counter (16374 bytes)
ROM:000009F0                 moveq   #0,d1            ; Clear d1
ROM:000009F2                 movea.l #$FFFF0000,a0    ; Set RAM address
ROM:000009F8 ClearRAMBuffer:                        ; CODE XREF: InitVDPForLogo+20↓j
ROM:000009F8                 move.l  d1,(a0)+         ; Clear RAM
ROM:000009FA                 dbf     d0,ClearRAMBuffer ; Loop for 16374 bytes
ROM:000009FE                 movea.l #VDP_CTRL,a4     ; Set VDP control port
ROM:00000A04                 movea.l #VDP_DATA,a5     ; Set VDP data port
ROM:00000A0A                 move.w  #$8004,(a4)      ; Set VDP register #0 (mode)
ROM:00000A0E                 move.w  #$8134,(a4)      ; Set VDP register #1 (display off)
ROM:00000A12                 move.w  #$8228,(a4)      ; Set VDP register #2 (plane A)
ROM:00000A16                 move.w  #$8330,(a4)      ; Set VDP register #3 (plane W)
ROM:00000A1A                 move.w  #$8405,(a4)      ; Set VDP register #4 (plane B)
ROM:00000A1E                 move.w  #$856E,(a4)      ; Set VDP register #5 (sprite table)
ROM:00000A22                 move.w  #$8700,(a4)      ; Set VDP register #7 (background)
ROM:00000A26                 move.w  #$8B03,(a4)      ; Set VDP register #11 (scroll)
ROM:00000A2A                 move.w  #$9003,(a4)      ; Set VDP register #16 (screen size)
ROM:00000A2E                 move.w  #$8C81,(a4)      ; Set VDP register #12 (mode)
ROM:00000A32                 move.w  #$8D08,(a4)      ; Set VDP register #13 (H-scroll)
ROM:00000A36                 move.w  #$8F02,(a4)      ; Set VDP register #15 (auto-inc)
ROM:00000A3A                 move.w  #$9100,(a4)      ; Set VDP register #17 (window H)
ROM:00000A3E                 move.w  #$9200,(a4)      ; Set VDP register #18 (window V)
ROM:00000A42                 move.w  #$8A01,(a4)      ; Set VDP register #10 (H-int)
ROM:00000A46                 move.l  #$40000000,(VDP_CTRL).l ; Set VRAM address
ROM:00000A50                 move.w  #$3FFF,d1        ; Set loop counter (16383 longs)
ROM:00000A54                 moveq   #0,d0            ; Clear d0
ROM:00000A56 ClearVRAM:                             ; CODE XREF: InitVDPForLogo+7E↓j
ROM:00000A56                 move.l  d0,(a5)          ; Clear VRAM
ROM:00000A58                 dbf     d1,ClearVRAM     ; Loop for 16383 longs
ROM:00000A5C                 moveq   #0,d1            ; Clear d1
ROM:00000A5E                 move.l  #$40000010,(VDP_CTRL).l ; Set VRAM address
ROM:00000A68                 bsr.s   EALogoGraphicsInit ; Initialize logo graphics
ROM:00000A6A                 move.l  #$60000000,(VDP_CTRL).l ; Set sprite table
ROM:00000A74                 neg.w   d1               ; Negate d1
ROM:00000A76                 rts                      ; Return
ROM:00000A76 ; End of function InitVDPForLogo

; ===========================================================================
; EALogoGraphicsInit: Initializes graphics for EA logo animation
; Loads and processes graphics data for the EA logo and wordmark, setting up
; sprites and palettes for the animation.
; ===========================================================================
ROM:00000A78 EALogoGraphicsInit:                   ; CODE XREF: InitVDPForLogo+8E↑p
ROM:00000A78                 move.w  d1,(a5)          ; Write initial sprite data
ROM:00000A7A                 move.w  d1,(a5)          ; Write initial sprite data
ROM:00000A7C                 lea     (LogoGraphicsBuffer).l,a3 ; Load graphics buffer
ROM:00000A82                 move.w  #$20,d1          ; Set stride (32 bytes)
ROM:00000A86                 moveq   #8,d0            ; Set loop counter (9 iterations)
ROM:00000A88                 lea     WordmarkAnimationTable(pc),a0 ; Load animation table
ROM:00000A8C                 moveq   #0,d5            ; Clear counter
ROM:00000A8E ProcessAnimationStep:                  ; CODE XREF: EALogoGraphicsInit+72↓j
ROM:00000A8E                 moveq   #0,d4            ; Clear offset
ROM:00000A90                 moveq   #0,d2            ; Clear index
ROM:00000A92                 move.b  (a0)+,d2         ; Read animation step
ROM:00000A94                 bra.s   ProcessAnimationData  ; Process step
ROM:00000A96 ProcessAnimationData:                  ; CODE XREF: EALogoGraphicsInit:ProcessAnimationStep↓j
ROM:00000A96                 bsr.w   CalculateWordmarkIndex ; Calculate index
ROM:00000A9A                 movea.l #$66666666,a1    ; Set default pattern
ROM:00000AA0                 tst.w   d4               ; Check offset
ROM:00000AA2                 bne.s   SetPattern            ; Skip if non-zero
ROM:00000AA4                 movea.l #$44444444,a1    ; Set alternate pattern
ROM:00000AAA SetPattern:                            ; CODE XREF: EALogoGraphicsInit+2A↑j
ROM:00000AAA                 moveq   #7,d7            ; Set loop counter (8 iterations)
ROM:00000AAC WritePattern:                          ; CODE XREF: EALogoGraphicsInit+4C↓j
ROM:00000AAC                 tst.w   d2               ; Check animation step
ROM:00000AAE                 bne.s   ApplyPattern          ; Skip if non-zero
ROM:00000AB0                 cmpa.l  #$44444444,a1    ; Check pattern
ROM:00000AB6                 beq.s   ApplyPattern          ; Skip if default
ROM:00000AB8                 movea.l #$55555555,a1    ; Set blank pattern
ROM:00000ABE ApplyPattern:                          ; CODE XREF: EALogoGraphicsInit+36↑j
ROM:00000ABE                                         ; EALogoGraphicsInit+3E↑j
ROM:00000ABE                 move.l  a1,(a3,d6.w)     ; Write pattern to buffer
ROM:00000AC2                 add.w   d1,d6            ; Advance buffer
ROM:00000AC4                 dbf     d7,WritePattern  ; Loop for 8 iterations
ROM:00000AC8                 addq.w  #1,d4            ; Increment offset
ROM:00000ACA ProcessAnimationDataLoop:              ; CODE XREF: EALogoGraphicsInit+1C↑j
ROM:00000ACA                 dbf     d2,ProcessAnimationData ; Loop for animation step
ROM:00000ACE                 tst.w   d0               ; Check if done
ROM:00000AD0                 beq.s   TransferGraphicsData  ; Exit if done
ROM:00000AD2                 bsr.w   CalculateWordmarkIndex ; Calculate index
ROM:00000AD6                 movea.l #$55555555,a1    ; Set blank pattern
ROM:00000ADC                 move.l  a1,(a3,d6.w)     ; Write pattern
ROM:00000AE0                 add.w   d1,d6            ; Advance buffer
ROM:00000AE2                 move.l  a1,(a3,d6.w)     ; Write pattern
ROM:00000AE6                 addi.w  #$100,d5         ; Increment counter
ROM:00000AEA                 dbf     d0,ProcessAnimationStep ; Loop for 9 iterations
ROM:00000AEE TransferGraphicsData:                  ; CODE XREF: EALogoGraphicsInit+58↑j
ROM:00000AEE                 lea     (LogoGraphicsBuffer).l,a3 ; Load graphics buffer
ROM:00000AF4                 move.w  #$23F,d0         ; Set loop counter (576 longs)
ROM:00000AF8                 move.l  #$40200001,(VDP_CTRL).l ; Set VRAM address
ROM:00000B02 WriteGraphicsData:                     ; CODE XREF: EALogoGraphicsInit+8C↓j
ROM:00000B02                 move.l  (a3)+,(a5)       ; Write graphics to VDP
ROM:00000B04                 dbf     d0,WriteGraphicsData ; Loop for 576 longs
ROM:00000B08                 move.l  #$97B4,d6        ; Set data offset
ROM:00000B0E                 move.l  a4,-(sp)         ; Save a4
ROM:00000B10                 movea.l d6,a3            ; Set data pointer
ROM:00000B12                 lsr.w   #1,d6            ; Adjust offset
ROM:00000B14                 lea     WordmarkAnimationTable(pc),a0 ; Load animation table
ROM:00000B18                 lea     (WordmarkGraphicsBuffer).l,a6 ; Load VRAM buffer
ROM:00000B1E                 lea     WordmarkOffsetTable(pc),a4 ; Load wordmark data
ROM:00000B22                 move.w  #$20,d3          ; Set stride (32 bytes)
ROM:00000B26                 swap    d3               ; Swap stride
ROM:00000B28                 movea.l d3,a2            ; Copy stride
ROM:00000B2A                 movea.l d3,a1            ; Copy stride
ROM:00000B2C                 moveq   #8,d4            ; Set loop counter (9 iterations)
ROM:00000B2E ProcessWordmarkStep:                   ; CODE XREF: EALogoGraphicsInit+12C↓j
ROM:00000B2E                 move.b  (a0)+,d5         ; Read animation step
ROM:00000B30                 ext.w   d5               ; Extend to word
ROM:00000B32                 moveq   #5,d0            ; Set inner loop counter
ROM:00000B34 ProcessWordmarkIteration:              ; CODE XREF: EALogoGraphicsInit+122↓j
ROM:00000B34                 move.l  #$BBBBBBBB,(AnimationMask).l ; Set default mask
ROM:00000B3E                 tst.w   d5               ; Check animation step
ROM:00000B40                 ble.s   HandleEmptyStep       ; Handle zero/negative
ROM:00000B42                 cmp.w   #1,d5            ; Check if step == 1
ROM:00000B46                 bne.s   SetWordmarkData       ; Skip if not
ROM:00000B48                 move.l  #$22222222,(AnimationMask).l ; Set alternate mask
ROM:00000B52 SetWordmarkData:                       ; CODE XREF: EALogoGraphicsInit+CE↑j
ROM:00000B52                 cmp.w   #5,d0            ; Check if final iteration
ROM:00000B56                 bne.s   ApplyWordmarkData     ; Skip if not
ROM:00000B58                 move.l  #$EEEEEEEE,(AnimationMask).l ; Set final mask
ROM:00000B62 ApplyWordmarkData:                     ; CODE XREF: EALogoGraphicsInit+DE↑j
ROM:00000B62                 move.l  d3,d1            ; Copy position
ROM:00000B64                 move.l  a1,d2            ; Copy pointer
ROM:00000B66                 bsr.w   ProcessSpriteAnimation ; Process animation data
ROM:00000B6A HandleEmptyStep:                       ; CODE XREF: EALogoGraphicsInit+C8↑j
ROM:00000B6A                 tst.w   d5               ; Check animation step
ROM:00000B6C                 bne.s   ProcessOffsetData     ; Skip if non-zero
ROM:00000B6E                 move.l  #$22222222,(AnimationMask).l ; Set alternate mask
ROM:00000B78                 moveq   #0,d2            ; Clear index
ROM:00000B7A                 move.b  (a4)+,d2         ; Read wordmark offset
ROM:00000B7C                 beq.s   ApplyDefaultData      ; Skip if zero
ROM:00000B7E                 swap    d2               ; Swap offset
ROM:00000B80                 add.l   d3,d2            ; Add position
ROM:00000B82                 move.l  d3,d1            ; Copy position
ROM:00000B84                 bsr.w   ProcessSpriteAnimation ; Process animation data
ROM:00000B88 ApplyDefaultData:                      ; CODE XREF: EALogoGraphicsInit+104↑j
ROM:00000B88                 move.l  a2,d1            ; Copy stride
ROM:00000B8A                 move.l  a1,d2            ; Copy pointer
ROM:00000B8C                 bsr.w   ProcessSpriteAnimation ; Process animation data
ROM:00000B90 ProcessOffsetData:                     ; CODE XREF: EALogoGraphicsInit+F4↑j
ROM:00000B90                 addq.l  #4,a6            ; Advance VRAM buffer
ROM:00000B92                 subq.w  #1,d5            ; Decrement step
ROM:00000B94                 sub.l   a3,d3            ; Adjust position
ROM:00000B96                 adda.l  a3,a1            ; Adjust pointer
ROM:00000B98                 adda.l  d6,a2            ; Adjust stride
ROM:00000B9A                 dbf     d0,ProcessWordmarkIteration ; Loop for 6 iterations
ROM:00000B9E                 adda.l  #$E8,a6          ; Advance VRAM buffer
ROM:00000BA4                 dbf     d4,ProcessWordmarkStep ; Loop for 9 iterations
ROM:00000BA8                 movea.l (sp)+,a4         ; Restore a4
ROM:00000BAA                 lea     (WordmarkGraphicsBuffer).l,a3 ; Load VRAM buffer
ROM:00000BB0                 move.w  #$23F,d0         ; Set loop counter (576 longs)
ROM:00000BB4                 move.l  #$52200001,(VDP_CTRL).l ; Set VRAM address

; ===========================================================================
; Continuation of EALogoGraphicsInit: Initializes graphics for EA logo animation
; Loads and processes graphics data for the EA logo and wordmark, continuing
; from the previous cutoff. This section handles sprite and tile data setup for
; the ECA letters (green E, yellow C, blue A) and the sliding "ELECTRONIC ARTS"
; wordmark, which starts green and transitions to match each letter's color.
; ===========================================================================
ROM:00000BBE WriteLogoGraphics:                      ; CODE XREF: EALogoGraphicsInit+148↑j
ROM:00000BBE                 move.l  (a3)+,(a5)       ; Write graphics data to VDP data port
ROM:00000BC0                 dbf     d0,WriteLogoGraphics ; Loop for 576 longs to transfer graphics data
ROM:00000BC4                 move.l  #$5C000003,(VDP_CTRL).l ; Set VDP to sprite table address
ROM:00000BCE                 lea     (ELetterWordmarkData).l,a0 ; Load sprite data for E letter wordmark
ROM:00000BD4                 lea     (ELetterSpriteData).l,a1 ; Load additional sprite data for E letter
ROM:00000BDA                 moveq   #1,d1            ; Set initial tile index for wordmark
ROM:00000BDC                 moveq   #$50,d2          ; Set X position offset (80 pixels) for wordmark
ROM:00000BDE                 move.w  #$48,d3          ; Set Y position (72 pixels) for wordmark
ROM:00000BE2                 moveq   #0,d4            ; Clear Y offset for wordmark
ROM:00000BE4                 moveq   #$12,d5          ; Set sprite count for E letter wordmark
ROM:00000BE6                 bsr.w   SetupWordmarkSprites ; Call subroutine to set up E wordmark sprites
ROM:00000BEA                 lea     (CLetterWordmarkData).l,a0 ; Load sprite data for C letter wordmark
ROM:00000BF0                 lea     (CLetterSpriteData).l,a1 ; Load additional sprite data for C letter
ROM:00000BF6                 move.w  #$88,d2          ; Set X position offset (136 pixels) for wordmark
ROM:00000BFA                 move.w  #$48,d3          ; Set Y position (72 pixels) for wordmark
ROM:00000BFE                 move.w  #$48,d4          ; Set Y offset (72 pixels) for wordmark
ROM:00000C02                 moveq   #$24,d5          ; Set sprite count for C letter wordmark
ROM:00000C04                 bsr.w   SetupWordmarkSprites ; Call subroutine to set up C wordmark sprites
ROM:00000C08                 lea     (ALetterWordmarkData).l,a0 ; Load sprite data for A letter wordmark
ROM:00000C0E                 lea     (ALetterSpriteData).l,a1 ; Load additional sprite data for A letter
ROM:00000C14                 move.w  #$B0,d2          ; Set X position offset (176 pixels) for wordmark
ROM:00000C18                 move.w  #$46,d3          ; Set Y position (70 pixels) for wordmark
ROM:00000C1C                 move.w  #$90,d4          ; Set Y offset (144 pixels) for wordmark
ROM:00000C20                 moveq   #0,d5            ; Set sprite count for A letter wordmark
ROM:00000C22                 bsr.w   SetupWordmarkSprites ; Call subroutine to set up A wordmark sprites
ROM:00000C26                 lea     (LogoPaletteBuffer).l,a1 ; Load palette data for color transitions
ROM:00000C2C                 lea     LogoAnimationTable(pc),a3 ; Load animation data table
ROM:00000C30                 moveq   #0,d2            ; Clear tile index for palette processing
ROM:00000C32                 move.b  1(a3),d2         ; Read high byte of tile index
ROM:00000C36                 asl.w   #8,d2            ; Shift to form word
ROM:00000C38                 move.b  (a3),d2          ; Read low byte of tile index
ROM:00000C3A                 addq.w  #4,a3            ; Advance to next animation data entry
ROM:00000C3C                 bsr.w   ProcessLogoPalette ; Call subroutine to process palette data
ROM:00000C40                 lea     (LogoPaletteBuffer).l,a1 ; Reload palette data
ROM:00000C46                 move.w  (a1)+,d0         ; Read width of palette data
ROM:00000C48                 move.w  (a1)+,d1         ; Read height of palette data
ROM:00000C4A                 move.w  (a1)+,d2         ; Read tile count for palette
ROM:00000C4C                 moveq   #$F,d3           ; Set loop counter for 16 colors
ROM:00000C4E                 move.l  #$C0000000,(VDP_CTRL).l ; Set VDP to CRAM for palette updates
ROM:00000C58 WritePaletteColors:                     ; CODE XREF: EALogoGraphicsInit+1E2↓j
ROM:00000C58                 move.w  (a1)+,(a5)       ; Write palette color to VDP
ROM:00000C5A                 dbf     d3,WritePaletteColors ; Loop for 16 colors
ROM:00000C5E                 asl.w   #3,d0            ; Scale width (multiply by 8 for tile size)
ROM:00000C60                 subq.w  #1,d0            ; Adjust width for loop
ROM:00000C62                 move.l  #$40200000,(VDP_CTRL).l ; Set VDP to VRAM for tile data
ROM:00000C6C WriteTileData:                         ; CODE XREF: EALogoGraphicsInit+1F6↓j
ROM:00000C6C                 move.l  (a1)+,(a5)       ; Write tile data to VDP
ROM:00000C6E                 dbf     d0,WriteTileData ; Loop for width
ROM:00000C72                 move.l  #$40000002,(VDP_CTRL).l ; Set VDP to VRAM for sprite table
ROM:00000C7C                 move.w  #$720C,d6        ; Set base VDP address for sprite data
ROM:00000C80                 subq.w  #1,d1            ; Adjust height for loop
ROM:00000C82                 subq.w  #1,d2            ; Adjust tile count for loop
ROM:00000C84                 move.w  d2,d0            ; Copy tile count to d0
ROM:00000C86                 move.w  #$8001,d4        ; Set base tile index for sprites
ROM:00000C8A WriteSpriteTiles:                      ; CODE XREF: EALogoGraphicsInit+222↓j
ROM:00000C8A                 move.w  d6,(a4)          ; Write VDP address to control port
ROM:00000C8C                 addi.w  #$100,d6         ; Increment VDP address
ROM:00000C90                 move.w  d2,d0            ; Copy tile count
ROM:00000C92 WriteSpriteTileRow:                    ; CODE XREF: EALogoGraphicsInit+21E↓j
ROM:00000C92                 move.w  d4,(a5)          ; Write tile index to VDP
ROM:00000C94                 addq.w  #1,d4            ; Increment tile index
ROM:00000C96                 dbf     d0,WriteSpriteTileRow ; Loop for tile count
ROM:00000C9A                 dbf     d1,WriteSpriteTiles ; Loop for height
ROM:00000C9E                 move.w  #$7044,(a4)      ; Set VDP address for palette entry
ROM:00000CA2                 bsr.s   UpdatePaletteEntries ; Update palette entries
ROM:00000CA4                 move.w  #$7144,(a4)      ; Set VDP address for next palette entry
ROM:00000CA8                 bsr.s   UpdatePaletteEntries ; Update palette entries
ROM:00000CAA                 move.w  #$710C,(a4)      ; Set VDP address for next palette entry
ROM:00000CAE                 bsr.s   UpdatePaletteEntries ; Update palette entries
ROM:00000CB0                 move.w  #$7136,(a4)      ; Set VDP address for final palette entry
ROM:00000CB4                 move.w  d4,(a5)          ; Write final tile index to VDP
ROM:00000CB6                 move.w  #$96,(word_FFC002).l ; Set frame counter for animation timing
ROM:00000CBE                 rts                      ; Return
ROM:00000CBE ; End of function EALogoGraphicsInit

; ===========================================================================
; UpdatePaletteEntries: Updates palette entries for logo color changes
; Writes palette entries to the VDP to handle color transitions (green, yellow,
; blue) for the ECA letters and wordmark during the animation.
; ===========================================================================
ROM:00000CC0 UpdatePaletteEntries:                   ; CODE XREF: EALogoGraphicsInit+22A↑p
ROM:00000CC0                                         ; EALogoGraphicsInit+230↑p ...
ROM:00000CC0                 move.w  d4,(a5)          ; Write palette entry to VDP
ROM:00000CC2                 addq.w  #1,d4            ; Increment palette index
ROM:00000CC4                 move.w  d4,(a5)          ; Write next palette entry
ROM:00000CC6                 addq.w  #1,d4            ; Increment palette index
ROM:00000CC8                 rts                      ; Return
ROM:00000CC8 ; End of function UpdatePaletteEntries

; ===========================================================================
; ProcessLogoPalette: Processes palette data for logo animation
; Handles palette data for the ECA letters and wordmark, managing color
; transitions (e.g., green to yellow to blue) using run-length encoding (RLE).
; ===========================================================================
ROM:00000CCA ProcessLogoPalette:                    ; CODE XREF: EALogoGraphicsInit+1C4↑p
ROM:00000CCA                 movem.l d0-d7/a0-a6,-(sp) ; Save registers
ROM:00000CCE                 lea     (TempPaletteBuffer).l,a2 ; Load temporary palette buffer
ROM:00000CD4                 movea.l a2,a0            ; Copy buffer address
ROM:00000CD6                 move.l  #$20202020,d3    ; Set default palette fill value
ROM:00000CDC                 move.w  #$3FF,d0         ; Set loop counter (1023 longs)
ROM:00000CE0 ClearPaletteBuffer:                    ; CODE XREF: ProcessLogoPalette+1A↓j
ROM:00000CE0                 move.l  d3,(a0)          ; Fill buffer with default value
ROM:00000CE2                 addq.l  #4,a0            ; Advance buffer pointer
ROM:00000CE4                 dbf     d0,ClearPaletteBuffer ; Loop for 1023 longs
ROM:00000CE8                 move.w  #$FEE,d7         ; Set initial buffer index
ROM:00000CEC                 move.w  #0,d3            ; Clear bit counter
ROM:00000CF0                 moveq   #0,d6            ; Clear control byte counter
ROM:00000CF2 ProcessPaletteBits:                    ; CODE XREF: ProcessLogoPalette+4E↓j
ROM:00000CF2                                         ; ProcessPaletteBits+86↓j
ROM:00000CF2                 dbf     d3,ReadPaletteByte ; Loop if bit counter > 0
ROM:00000CF6                 move.b  (a3)+,d0         ; Read control byte from animation table
ROM:00000CF8                 move.b  d0,d6            ; Copy control byte for bit testing
ROM:00000CFA                 move.w  #7,d3            ; Set bit counter (8 bits)
ROM:00000CFE ReadPaletteByte:                       ; CODE XREF: ProcessLogoPalette:ProcessPaletteBits↑j
ROM:00000CFE                 move.b  (a3)+,d0         ; Read data byte from animation table
ROM:00000D00                 lsr.b   #1,d6            ; Shift control byte to test next bit
ROM:00000D02                 bcc.w   HandleRLEData     ; Branch if bit is clear (RLE data)
ROM:00000D06                 move.b  d0,(a1)+         ; Write data byte to palette buffer
ROM:00000D08                 subq.l  #1,d2            ; Decrement tile count
ROM:00000D0A                 beq.w   ExitPaletteProcessing ; Exit if no more tiles
ROM:00000D0E                 move.b  d0,(a2,d7.w)     ; Write data byte to temporary buffer
ROM:00000D12                 addq.w  #1,d7            ; Increment buffer index
ROM:00000D14                 andi.w  #$FFF,d7         ; Wrap index at 4096
ROM:00000D18                 bra.s   ProcessPaletteBits ; Continue processing bits
ROM:00000D1A HandleRLEData:                         ; CODE XREF: ProcessLogoPalette+38↑j
ROM:00000D1A                 moveq   #0,d4            ; Clear run length counter
ROM:00000D1C                 move.b  d0,d4            ; Copy data byte to run length
ROM:00000D1E                 move.b  (a3)+,d0         ; Read next byte (run count)
ROM:00000D20                 move.b  d0,d5            ; Copy to run counter
ROM:00000D22                 andi.w  #$F0,d0          ; Mask high nibble for index
ROM:00000D26                 asl.w   #4,d0            ; Shift to form index
ROM:00000D28                 or.w    d0,d4            ; Combine with data byte
ROM:00000D2A                 andi.w  #$F,d5           ; Mask low nibble for run count
ROM:00000D2E                 addq.w  #2,d5            ; Adjust run length (add 2)
ROM:00000D30 CopyRLEData:                           ; CODE XREF: ProcessLogoPalette+82↓j
ROM:00000D30                 move.b  (a2,d4.w),d0     ; Read byte from temporary buffer
ROM:00000D34                 addq.w  #1,d4            ; Increment buffer index
ROM:00000D36                 andi.w  #$FFF,d4         ; Wrap index at 4096
ROM:00000D3A                 move.b  d0,(a1)+         ; Write byte to palette buffer
ROM:00000D3C                 subq.l  #1,d2            ; Decrement tile count
ROM:00000D3E                 beq.w   ExitPaletteProcessing ; Exit if no more tiles
ROM:00000D42                 move.b  d0,(a2,d7.w)     ; Write byte to temporary buffer
ROM:00000D46                 addq.w  #1,d7            ; Increment buffer index
ROM:00000D48                 andi.w  #$FFF,d7         ; Wrap index at 4096
ROM:00000D4C                 dbf     d5,CopyRLEData   ; Loop for run length
ROM:00000D50                 bra.s   ProcessPaletteBits ; Continue processing bits
ROM:00000D52 ExitPaletteProcessing:                 ; CODE XREF: ProcessLogoPalette+40↑j
ROM:00000D52                                         ; ProcessLogoPalette+74↑j
ROM:00000D52                 movem.l (sp)+,d0-d7/a0-a6 ; Restore registers
ROM:00000D56                 rts                      ; Return
ROM:00000D56 ; End of function ProcessLogoPalette